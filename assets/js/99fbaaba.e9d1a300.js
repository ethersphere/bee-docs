"use strict";(self.webpackChunkbee_docs=self.webpackChunkbee_docs||[]).push([[5908],{28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>d});var i=s(96540);const t={},r=i.createContext(t);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(r.Provider,{value:n},e.children)}},73882:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"develop/tools-and-features/gsoc","title":"GSOC","description":"Introduction","source":"@site/docs/develop/tools-and-features/gsoc.md","sourceDirName":"develop/tools-and-features","slug":"/develop/tools-and-features/gsoc","permalink":"/docs/develop/tools-and-features/gsoc","draft":false,"unlisted":false,"editUrl":"https://github.com/ethersphere/docs.github.io/blob/master/docs/develop/tools-and-features/gsoc.md","tags":[],"version":"current","frontMatter":{"title":"GSOC","id":"gsoc"},"sidebar":"develop","previous":{"title":"PSS Messaging","permalink":"/docs/develop/tools-and-features/pss"},"next":{"title":"Developer mode","permalink":"/docs/develop/tools-and-features/bee-dev-mode"}}');var t=s(74848),r=s(28453);const o={title:"GSOC",id:"gsoc"},d=void 0,c={},a=[{value:"Introduction",id:"introduction",level:2},{value:"<em>bee-js</em> GSOC Methods",id:"bee-js-gsoc-methods",level:2},{value:"<code>Bee.gsocMine()</code>",id:"beegsocmine",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Functionality:",id:"functionality",level:4},{value:"<code>Bee.gsocSend()</code>",id:"beegsocsend",level:3},{value:"Parameters:",id:"parameters-1",level:4},{value:"Functionality:",id:"functionality-1",level:4},{value:"<code>Bee.gsocSubscribe()</code>",id:"beegsocsubscribe",level:3},{value:"Parameters:",id:"parameters-2",level:4},{value:"Functionality:",id:"functionality-2",level:4},{value:"Example Scripts",id:"example-scripts",level:2},{value:"Script Requirements",id:"script-requirements",level:3},{value:"Service Node Script",id:"service-node-script",level:3},{value:"Initialize Project",id:"initialize-project",level:4},{value:"Update Configuration",id:"update-configuration",level:4},{value:"Run Service Node Script",id:"run-service-node-script",level:4},{value:"Writer Node Script",id:"writer-node-script",level:3},{value:"Initialize Project",id:"initialize-project-1",level:4},{value:"Update Configuration",id:"update-configuration-1",level:4},{value:"Run Writer Node Script",id:"run-writer-node-script",level:4}];function l(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsxs)(n.p,{children:["The Graffiti Several Owner Chunk (GSOC) feature enables a single Bee ",(0,t.jsx)(n.em,{children:"service"})," node to receive messages from multiple Bee ",(0,t.jsx)(n.em,{children:"writer"})," nodes. It is based on a ",(0,t.jsx)(n.a,{href:"/docs/develop/tools-and-features/chunk-types/#single-owner-chunks",children:"Single Owner Chunk (SOC)"})," with an address which is derived so that it falls within the neighborhood of the service node, ensuring updates are automatically synced as part of the normal full node syncing process."]}),"\n",(0,t.jsxs)(n.p,{children:["The service node determines the data used to derive the GSOC private key. Any node with access to this data can derive the same private key and update the GSOC in order to send messages to the service node. Since only full nodes sync neighborhood chunks, the service node ",(0,t.jsx)(n.em,{children:"must be a full node to receive GSOC updates"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"To receive messages in real time, the service node establishes a WebSocket connection to listen for GSOC update events. When a matching SOC update reaches a node with an active GSOC connection, an event is emitted, enabling the service node to dynamically receive messages as part of a many-to-one notification system."}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{}),(0,t.jsxs)(n.p,{children:["GSOC was initially introduced in a ",(0,t.jsx)(n.a,{href:"https://github.com/ethersphere/SWIPs/blob/99e6cf90a4768b24d27e5339b205c18825b53322/SWIPs/swip-draft_graffiti-soc.md#gsoc-identifier",children:"SWIP"}),", which outlines its core concepts and implementation details, and it is an evolution of the earlier ",(0,t.jsx)(n.a,{href:"https://github.com/fairDataSociety/FIPs/blob/master/text/0062-graffiti-feed.md",children:"Graffiti feed"})," feature."]})]}),"\n",(0,t.jsxs)(n.h2,{id:"bee-js-gsoc-methods",children:[(0,t.jsx)(n.em,{children:"bee-js"})," GSOC Methods"]}),"\n",(0,t.jsxs)(n.p,{children:["While you can interact with GSOC directly via the ",(0,t.jsx)(n.code,{children:"/gsoc/subscribe/{address}"})," endpoint, the ",(0,t.jsx)(n.a,{href:"/docs/develop/tools-and-features/bee-js/",children:"bee-js"})," library is the recommended way for most users. The library includes three methods which make it easy to get started with GSOC:"]}),"\n",(0,t.jsx)(n.h3,{id:"beegsocmine",children:(0,t.jsx)(n.code,{children:"Bee.gsocMine()"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Bee.gsocMine"})," method mines a GSOC private key corresponding to a specific overlay address:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The service node uses this method to generate the private key for a GSOC in its own neighborhood, and then uses it with the ",(0,t.jsx)(n.code,{children:"gsocSubscribe"})," method to listen for updates from writer nodes."]}),"\n",(0,t.jsxs)(n.li,{children:["A writer node uses this method to generate the private key it uses to send messages to the service node with the ",(0,t.jsx)(n.code,{children:"gsocSend()"})," method."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"targetOverlay"})})," (",(0,t.jsx)(n.code,{children:"PeerAddress | Uint8Array | string"}),") \u2013 The overlay address of the service node."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"identifier"})})," (",(0,t.jsx)(n.code,{children:"Identifier | Uint8Array | string"}),") \u2013 A unique, arbitrary value that can be modified to mine a GSOC private key derived from a specific value."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"proximity"})})," (",(0,t.jsx)(n.code,{children:"number"}),", default: ",(0,t.jsx)(n.code,{children:"16"}),") \u2013 Determines the neighborhood depth, i.e., how many prefix bits match between ",(0,t.jsx)(n.code,{children:"targetOverlay"})," and the mined GSOC overlay address."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The function returns a mined private key, which corresponds to a GSOC overlay address that falls within the ",(0,t.jsx)(n.code,{children:"targetOverlay"})," neighborhood."]}),"\n",(0,t.jsx)(n.h4,{id:"functionality",children:"Functionality:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Mines and returns a private key that generates a GSOC overlay address within the specified ",(0,t.jsx)(n.code,{children:"proximity"})," of ",(0,t.jsx)(n.code,{children:"targetOverlay"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The service node uses this method to mine a GSOC chunk whose overlay falls within its own neighborhood, and shares the values used as input with the writer node (",(0,t.jsx)(n.code,{children:"targetOverlay"}),", ",(0,t.jsx)(n.code,{children:"identifier"}),", and ",(0,t.jsx)(n.code,{children:"proximity"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"The writer node uses this method with the input values shared from the service node to generate the private key that allows it to send messages as updates to the mined GSOC."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This function allows users to derive a GSOC overlay address that aligns with a target node\u2019s network neighborhood."}),"\n",(0,t.jsx)(n.h3,{id:"beegsocsend",children:(0,t.jsx)(n.code,{children:"Bee.gsocSend()"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Bee.gsocSend"})," method is used by a writer node for sending GSOC messages. It creates an update for the GSOC using the provided ",(0,t.jsx)(n.code,{children:"data"})," as the message, signs the update with the private key mined by the ",(0,t.jsx)(n.code,{children:"gsocMine()"})," method, and uploads it to Swarm."]}),"\n",(0,t.jsx)(n.h4,{id:"parameters-1",children:"Parameters:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"postageBatchId"})})," (",(0,t.jsx)(n.code,{children:"BatchId | Uint8Array | string"}),") \u2013 The ID of the postage batch used to pay for the upload."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"signer"})})," (",(0,t.jsx)(n.code,{children:"PrivateKey | Uint8Array | string"}),") \u2013 The private key used to sign the chunk."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"identifier"})})," (",(0,t.jsx)(n.code,{children:"Identifier | Uint8Array | string"}),") \u2013 A unique identifier for the GSOC."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"data"})})," (",(0,t.jsx)(n.code,{children:"string | Uint8Array"}),") \u2013 The payload to be sent."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"options"})})," (",(0,t.jsx)(n.code,{children:"UploadOptions"}),", optional) \u2013 Additional upload configuration."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"requestOptions"})})," (",(0,t.jsx)(n.code,{children:"BeeRequestOptions"}),", optional) \u2013 Custom request options."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"functionality-1",children:"Functionality:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Used by the writer node to send a GSOC message using the private key returned from ",(0,t.jsx)(n.code,{children:"gsocMine()"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Requires the ",(0,t.jsx)(n.code,{children:"postageBatchId"})," for a valid postage stamp batch (ideally ",(0,t.jsx)(n.a,{href:"/docs/develop/tools-and-features/gsoc#script-requirements",children:"mutable"}),") to send messages."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"beegsocsubscribe",children:(0,t.jsx)(n.code,{children:"Bee.gsocSubscribe()"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Bee.gsocSubscribe"})," method is used by the service node to establish a WebSocket connection to listen for GSOC messages. It subscribes to messages associated with a specific ",(0,t.jsx)(n.code,{children:"address"})," and ",(0,t.jsx)(n.code,{children:"identifier"}),"."]}),"\n",(0,t.jsx)(n.h4,{id:"parameters-2",children:"Parameters:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"address"})})," (",(0,t.jsx)(n.code,{children:"EthAddress | Uint8Array | string"}),") \u2013 The Gnosis Chain address associated with the private key returned by the ",(0,t.jsx)(n.code,{children:"gsocMine()"})," function."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"identifier"})})," (",(0,t.jsx)(n.code,{children:"Identifier | Uint8Array | string"}),") \u2013 A unique identifier used to track the messages."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.code,{children:"handler"})})," (",(0,t.jsx)(n.code,{children:"GsocMessageHandler"}),") \u2013 A callback function to handle incoming messages."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"functionality-2",children:"Functionality:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["The function is used by the service node to construct a GSOC address using the provided ",(0,t.jsx)(n.code,{children:"identifier"})," and ",(0,t.jsx)(n.code,{children:"address"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"A WebSocket connection is opened to subscribe to update events for this GSOC address."}),"\n",(0,t.jsxs)(n.li,{children:["Incoming messages are processed by the ",(0,t.jsx)(n.code,{children:"handler"})," function."]}),"\n",(0,t.jsxs)(n.li,{children:["The function returns a ",(0,t.jsx)(n.code,{children:"GsocSubscription"})," object with a ",(0,t.jsx)(n.code,{children:"cancel"})," method to terminate the subscription."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"example-scripts",children:"Example Scripts"}),"\n",(0,t.jsxs)(n.p,{children:["The service node and writer node scripts below are a minimalistic example of how to use ",(0,t.jsx)(n.code,{children:"bee-js"})," to set up a service node to listen for GSOC messages, and a writer node to send GSOC messages."]}),"\n",(0,t.jsx)(n.h3,{id:"script-requirements",children:"Script Requirements"}),"\n",(0,t.jsx)(n.p,{children:"To run both nodes and send messages from the writer node to the service node you will need:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"A fully synced Bee full node for the service node and a second Bee light node for the writer node (they do not both need to be running on the same machine)"}),"\n",(0,t.jsx)(n.li,{children:"A small amount of xDAI (~0.01) and xBZZ (~0.01)"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://nodejs.org/en",children:"NodeJS"})," & ",(0,t.jsx)(n.a,{href:"https://www.npmjs.com/",children:"NPM"})]}),"\n",(0,t.jsxs)(n.li,{children:["A mutable stamp batch (",(0,t.jsx)(n.em,{children:"set the"})," ",(0,t.jsxs)(n.a,{href:"/api/#tag/Postage-Stamps/paths/~1stamps~1%7Bamount%7D~1%7Bdepth%7D/post",children:[(0,t.jsx)(n.code,{children:"immutable"})," header parameter"]})," ",(0,t.jsxs)(n.em,{children:["to ",(0,t.jsx)(n.code,{children:"false"})," when"]})," ",(0,t.jsx)(n.a,{href:"/docs/develop/access-the-swarm/buy-a-stamp-batch#buying-a-stamp-batch",children:"buying a batch"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{}),(0,t.jsxs)(n.p,{children:["Only ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"mutable"})})," postage stamp batches should be used for GSOC."]}),(0,t.jsxs)(n.p,{children:["Since each GSOC update utilizes one slot within the ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"same"})})," ",(0,t.jsx)(n.a,{href:"/docs/concepts/incentives/postage-stamps#batch-utilisation",children:"postage batch bucket"}),", immutable batches will fill up very quickly (e.g., at depth 18, four GSOC messages exhaust the batch)."]}),(0,t.jsx)(n.p,{children:"Mutable batches allow updates to overwrite older ones, preventing full utilization and enabling indefinite GSOC messaging as long as the batch still has remaining TTL."})]}),"\n",(0,t.jsx)(n.h3,{id:"service-node-script",children:"Service Node Script"}),"\n",(0,t.jsxs)(n.p,{children:["\u2705 For your service node project, you must use a ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"full node"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:"\u274c A service node does not need a postage stamp batch."}),"\n",(0,t.jsx)(n.h4,{id:"initialize-project",children:"Initialize Project"}),"\n",(0,t.jsx)(n.p,{children:"First, initialize the service node project on a machine running a full Bee node in the background:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'mkdir service-node\ncd service-node\nnpm init -y && npm pkg set type="module" && cat package.json\nnpm install @upcoming/bee-js --save\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The command first creates the ",(0,t.jsx)(n.code,{children:"service-node"})," directory, moves into that directory, initializes a ",(0,t.jsx)(n.code,{children:"package.json"})," file, sets ",(0,t.jsx)(n.code,{children:'"type": "module"'})," in the file, and finally installs the ",(0,t.jsx)(n.code,{children:"bee-js"})," library."]}),"\n",(0,t.jsxs)(n.p,{children:["Next create a file named ",(0,t.jsx)(n.code,{children:"index.js"})," which will hold the code for our service node."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"touch index.js\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then open in your editor of choice:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"vi index.js\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Copy the completed code below for a service node into our newly created ",(0,t.jsx)(n.code,{children:"index.js"})," file:"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Read through the code and code comments for a more in-depth understanding of how the service node works."})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { Bee, NULL_IDENTIFIER } from '@upcoming/bee-js';\n\n// Configuration\nconst BEE_HOST = 'http://localhost:1633'; // Change this if necessary\nconst BEE_PROXIMITY = 12 // Mining depth of the GSOC overlay - modified from the default of 16 for a shorter mining time\n\nconst BEE = new Bee(BEE_HOST, {});\nasync function mineGsocKey() {\n    console.log('Fetching node addresses...');\n    const addresses = await BEE.getNodeAddresses();\n    const privateKey = BEE.gsocMine(addresses.overlay, NULL_IDENTIFIER, BEE_PROXIMITY); // `NULL_IDENTIFIER` is a constant `Uint8Array(32)` imported from `bee-js` for use as a default identifier\n    console.log('Mining completed. Public Key:', privateKey.publicKey().toCompressedHex());\n    return privateKey;\n}\n\nasync function createGsocListener() {\n    try {\n        const privateKey = await mineGsocKey();\n        // Subscribe to GSOC messages\n        const subscription = BEE.gsocSubscribe(privateKey.publicKey().address(), NULL_IDENTIFIER, {\n            onMessage: message => console.log('Received GSOC update:', message.toJSON()),\n            onError: err => console.error('Error in subscription:', err),\n        });\n\n        console.log('Listening for GSOC updates...');\n\n        return { privateKey, subscription };\n    } catch (err) {\n        console.error('Error:', err.message);\n    }\n}\n\n(async () => {\n    await createGsocListener();\n})();\n"})}),"\n",(0,t.jsx)(n.h4,{id:"update-configuration",children:"Update Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Update the constants in the configuration section with your own information:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Update ",(0,t.jsx)(n.code,{children:"BEE_HOST"})," if your node is not using the default ",(0,t.jsx)(n.code,{children:"http://localhost:1633"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"run-service-node-script",children:"Run Service Node Script"}),"\n",(0,t.jsx)(n.p,{children:"Start the service node:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"node index.js\n"})}),"\n",(0,t.jsx)(n.p,{children:"If everything is working correctly, after a few seconds you should see output like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"Fetching node addresses...\nNode overlay address:  75703155f54cbb899a359a7e3daec75da7722baef9286522e58e86ccbfcd7f13\nMining completed. Public Key: e82d2c98a92a3b0c690f6ba28070c59e3e0cd0a2a384d3b03cba9d1fded41a9831e73a3232d85b3614833d344c7d502dd09d7ecd0614b06095c86be0c8501460\nListening for GSOC updates...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This means the service node has successfully mined a GSOC chunk that it falls into its own neighborhood, and is now listening for updates on that chunk. Copy the ",(0,t.jsx)(n.code,{children:"Node overlay address:"})," value (",(0,t.jsx)(n.code,{children:"75703155f54cbb899a359a7e3daec75da7722baef9286522e58e86ccbfcd7f13"})," from the example output) and save it - we will need it for our writer node's configuration."]}),"\n",(0,t.jsx)(n.h3,{id:"writer-node-script",children:"Writer Node Script"}),"\n",(0,t.jsx)(n.p,{children:"\u2705 For your writer node, either a light or a full node can be used"}),"\n",(0,t.jsxs)(n.p,{children:["\u2705 A writer node needs a valid ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"mutable"})})," (not technically required, but ",(0,t.jsx)(n.a,{href:"/docs/develop/tools-and-features/gsoc#script-requirements",children:"strongly recommended"}),") postage stamp batch in order to send GSOC messages"]}),"\n",(0,t.jsx)(n.h4,{id:"initialize-project-1",children:"Initialize Project"}),"\n",(0,t.jsx)(n.p,{children:"We initialize our writer node using almost the same command as our service node, only the directory name has been changed."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'mkdir writer-node\ncd writer-node\nnpm init -y && npm pkg set type="module" && cat package.json\nnpm install @upcoming/bee-js --save\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The command first creates the ",(0,t.jsx)(n.code,{children:"writer-node"})," directory, moves into that directory, initializes a ",(0,t.jsx)(n.code,{children:"package.json"})," file, sets ",(0,t.jsx)(n.code,{children:'"type": "module"'})," in the file, and finally installs the ",(0,t.jsx)(n.code,{children:"bee-js"})," library."]}),"\n",(0,t.jsxs)(n.p,{children:["Next create a file named ",(0,t.jsx)(n.code,{children:"index.js"})," which will hold the code for our writer node."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"touch index.js\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then open in your editor of choice:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"vi index.js\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Copy the completed code below for a writer node into our newly created ",(0,t.jsx)(n.code,{children:"index.js"})," file:"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Read through the code and code comments for a more in-depth understanding of how the writer node works."})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { Bee, NULL_IDENTIFIER } from '@upcoming/bee-js';\n\n// Configuration\nconst BEE_HOST = 'http://localhost:1643'; // Change this if necessary\nconst BEE_BATCH = '42a10176596ecc73dcd24b91a16fb77d874ebd108fe8bc7fb896c8e89e8cb06e'; // Ensure this is a valid hex string\nconst TARGET_OVERLAY = '75703155f54cbb899a359a7e3daec75da7722baef9286522e58e86ccbfcd7f13'; // Overlay of service node writer node wants to message\nconst BEE_PROXIMITY = 12  // Mining depth of the GSOC overlay - modified from the default of 16 for a shorter mining time\n\nconst BEE = new Bee(BEE_HOST, {});\n\nasync function mineGsocKey() {\n    const privateKey = BEE.gsocMine(TARGET_OVERLAY, NULL_IDENTIFIER, BEE_PROXIMITY); // `NULL_IDENTIFIER` is a constant `Uint8Array(32)` imported from `bee-js` for use as a default identifier\n    console.log('Mining completed. Public Key:', privateKey.publicKey().toCompressedHex());\n    return privateKey;\n}\n\nasync function sendGsocMessage(privateKey, name, body) {\n    if (!privateKey) {\n        console.error('Error: Private key is not available');\n        return;\n    }\n\n    if (!/^[0-9a-fA-F]{64}$/.test(BEE_BATCH)) {\n        console.error('Error: Invalid BEE_BATCH. It must be a 64-character hex string.');\n        return;\n    }\n\n    const message = JSON.stringify({ name, body });\n    await BEE.gsocSend(BEE_BATCH, privateKey, NULL_IDENTIFIER, message); \n    console.log('Message sent:', message);\n}\n\n(async () => {\n    const privateKey = await mineGsocKey();\n\n    // Example: Sending a message after a delay (simulate user input)\n    setTimeout(() => {\n        sendGsocMessage(privateKey, 'Alice', 'Hello from Node.js!');\n    }, 5000);\n})();\n"})}),"\n",(0,t.jsx)(n.h4,{id:"update-configuration-1",children:"Update Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Update the configuration section constants with your own information:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Set ",(0,t.jsx)(n.code,{children:"BEE_HOST"})," to your writer node's API endpoint"]}),"\n",(0,t.jsxs)(n.li,{children:["Set ",(0,t.jsx)(n.code,{children:"BEE_BATCH"})," to the batch id of a valid, ",(0,t.jsx)(n.em,{children:"mutable"})," postage stamp batch - ",(0,t.jsx)(n.a,{href:"/docs/develop/access-the-swarm/buy-a-stamp-batch",children:"buy a batch"})," if needed"]}),"\n",(0,t.jsxs)(n.li,{children:["Set ",(0,t.jsx)(n.code,{children:"TARGET_OVERLAY"})," to the service node overlay value we copied from the output of the service node script"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"After updating the configuration, run the writer node script (before running the writer node script, make sure the service node script has already been started and is currently listening for GSOC updates):"}),"\n",(0,t.jsx)(n.h4,{id:"run-writer-node-script",children:"Run Writer Node Script"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"node index.js\n"})}),"\n",(0,t.jsx)(n.p,{children:"If everything is working correctly, after a few moments on your writer node you should see output like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'Mining completed. Public Key: e82d2c98a92a3b0c690f6ba28070c59e3e0cd0a2a384d3b03cba9d1fded41a9831e73a3232d85b3614833d344c7d502dd09d7ecd0614b06095c86be0c8501460\nMessage sent: {"name":"Alice","body":"Hello from Node.js!"}\n'})}),"\n",(0,t.jsx)(n.p,{children:"While in the output from our service node, we should receive the update:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"Received GSOC update: { name: 'Alice', body: 'Hello from Node.js!' }\n"})}),"\n",(0,t.jsx)(n.p,{children:"Congratulations! You've just sent your first GSOC message."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);