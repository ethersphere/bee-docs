"use strict";(self.webpackChunkbee_docs=self.webpackChunkbee_docs||[]).push([[7165],{7734:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>t,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>h,toc:()=>a});var s=d(74848),r=d(28453);const o={title:"Neighbourhoods",id:"neighbourhoods"},i=void 0,h={id:"learn/advanced/neighbourhoods",title:"Neighbourhoods",description:"A neighbourhood is a group of nodes which are responsible for storing the same chunks of data. The nodes which make up a neighbourhood and the chunks which they are responsible for storing are determined by the node and chunk addresses. Node and chunk addresses follow the same format of a 256 bit hexadecimal number.",source:"@site/docs/learn/advanced/neighbourhoods.md",sourceDirName:"learn/advanced",slug:"/learn/advanced/neighbourhoods",permalink:"/docs/learn/advanced/neighbourhoods",draft:!1,unlisted:!1,editUrl:"https://github.com/ethersphere/docs.github.io/blob/master/docs/learn/advanced/neighbourhoods.md",tags:[],version:"current",frontMatter:{title:"Neighbourhoods",id:"neighbourhoods"},sidebar:"learn",previous:{title:"Erasure Cost Calculation",permalink:"/docs/learn/advanced/erasure-cost-calculation"},next:{title:"Tokens",permalink:"/docs/learn/tokens"}},t={},a=[{value:"Example Neighbourhood",id:"example-neighbourhood",level:3},{value:"Chunk Neighbourhood Assignment",id:"chunk-neighbourhood-assignment",level:3},{value:"Neighbourhood Doubling",id:"neighbourhood-doubling",level:3},{value:"Doubling Implications for Node Operators",id:"doubling-implications-for-node-operators",level:3}];function l(e){const n={a:"a",admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",em:"em",h3:"h3",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"A neighbourhood is a group of nodes which are responsible for storing the same chunks of data. The nodes which make up a neighbourhood and the chunks which they are responsible for storing are determined by the node and chunk addresses. Node and chunk addresses follow the same format of a 256 bit hexadecimal number."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Swarm address: ",(0,s.jsx)(n.code,{children:"da7e5cc3ed9a46b6e7491d3bf738535d98112641380cbed2e9ddfe4cf4fc01c4"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Neighbourhoods are formed by nodes which share a certain number of leading bits in their addresses. The number of leading bits is variable and can increase as more data enters the network, this number is referred to as the ",(0,s.jsx)(n.a,{href:"/docs/learn/glossary#2b-storage-depth",children:"storage depth"}),' (the term "radius" is sometimes used as an alternative to depth, so you may see "storage radius" in some documentation). Nodes in a neighbourhood are responsible for storing chunks which share the same leading bits with the nodes in the neighbourhood up to the storage depth.']}),"\n",(0,s.jsx)(n.h3,{id:"example-neighbourhood",children:"Example Neighbourhood"}),"\n",(0,s.jsx)(n.p,{children:"Let's take a closer look at an example. Below is a neighbourhood of six nodes at depth 10. Each node is identified by its Swarm address, which is a 256 bit hexadecimal number derived from the node's Gnosis Chain address, the Swarm network id, and a random nonce."}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"da4cb0d125bba638def55c0061b00d7c01ed4033fa193d6e53a67183c5488d73\nda5d39a5508fadf66c8665d5e51617f0e9e5fd501e429c38471b861f104c1504\nda7a974149543df1b459831286b42b302f22393a20e9b3dd9a7bb5a7aa5af263\nda76f8fccc3267b589d822f1c601b21b525fdc2598df97856191f9063029d21e\nda7b6439c8d3803286b773a56c4b9a38776b5cd0beb8fd628b6007df235cf35c\nda7fd412b79358f84b7928d2f6b7ccdaf165a21313608e16edd317a5355ba250"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Since we are only concerned with the leading binary bits close to the neighbourhood depth, for the rest of this example we will abbreviate the addresses to the first four prefixed hexadecimal digits only. Below are listed the hex prefixes and their binary representation, with the first ten leading bits underlined:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Hex prefix"}),(0,s.jsx)(n.th,{children:"Binary Bits"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da4c"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"1101101001"}),"001100"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da5d"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"1101101001"}),"011101"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da76"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"1101101001"}),"110110"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da7a"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"1101101001"}),"111010"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da7b"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"1101101001"}),"111011"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da7f"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"1101101001"}),"111111"]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"chunk-neighbourhood-assignment",children:"Chunk Neighbourhood Assignment"}),"\n",(0,s.jsx)(n.p,{children:"Chunks are assigned to neighbourhoods based on their addresses, which are in the same 256 bit format as node addresses. Here are two example chunks which fall within our example neighbourhood:"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["Chunk A address: ",(0,s.jsx)(n.code,{children:"da49a42926015cd1e2bc552147c567b1ca13e8d4302c9e6026e79a24de328b65"}),(0,s.jsx)(n.br,{}),"\n","Chunk B address: ",(0,s.jsx)(n.code,{children:"da696a3dfb0f7f952872eb33e0e2a1435c61f111ff361e64203b5348cc06dc8a"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["As the address of the chunk shown above shares the same ten leading binary bits as the nodes in our example neighbourhood, it falls into that neighbourhood's ",(0,s.jsx)(n.a,{href:"/docs/learn/glossary#2-area-of-responsibility-related-depths",children:"area of responsibility"}),", and all the nodes in that neighbourhood are required to store that chunk:"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["da49 --\x3e ",(0,s.jsx)("u",{children:"1101101001"}),"001001",(0,s.jsx)(n.br,{}),"\n","da69 --\x3e ",(0,s.jsx)("u",{children:"1101101001"}),"101001"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"As with the example for nodes, we've abbreviated the chunk addresses to their leading four hexadecimal digits only and converted them to binary digits."})}),"\n",(0,s.jsx)(n.h3,{id:"neighbourhood-doubling",children:"Neighbourhood Doubling"}),"\n",(0,s.jsx)(n.p,{children:'As more and more chunks are assigned to neighbourhoods, the chunk reserves of the nodes in that neighbourhood will begin to fill up. Once the nodes\' reserves in a neighbourhood become full and can no longer store additional chunks, that neighbourhood will split, with each half of the neighbourhood taking responsibility for half of the chunks. This event is referred to as a "doubling", as it results in double the number of neighbourhoods. The split is done by increasing the storage depth by one, so that the number of shared leading bits is increased by one. This results in a binary splitting of the neighbourhood and associated chunks into two new neighbourhoods and respective groups of chunks.'}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:'Note that when chunks begin to expire and new chunks are not uploaded to Swarm, it is possible for node\'s reserves to empty out, once they fall below a certain threshold, a "halving" will occur in which the storage depth will be decreased by one and two neighbourhoods will merge to make a new one so that they are responsible for a wider set of chunks.'})}),"\n",(0,s.jsx)(n.p,{children:"Using our previous example neighbourhood, during a doubling, the storage depth would increase from 10 to 11, and the neighbourhood would be split based on the 11th leading bit."}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Neighbourhood A:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Hex prefix"}),(0,s.jsx)(n.th,{children:"Binary Bits"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da4c"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010010"}),"01100"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da5d"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010010"}),"11101"]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Neighbourhood B:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Hex prefix"}),(0,s.jsx)(n.th,{children:"Binary Bits"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da76"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010011"}),"10110"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da7a"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010011"}),"11010"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da7b"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010011"}),"11011"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da7f"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010011"}),"11111"]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"Each of our two example chunks will also be split amongst the two new neighbourhoods based on their 11th leading bit:"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Neighbourhood A:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Hex prefix"}),(0,s.jsx)(n.th,{children:"Binary Bits"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da4c"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010010"}),"01100"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da5d"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010010"}),"11101"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da49 (chunk)"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010010"}),"01001"]})]})]})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Neighbourhood B:"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Hex prefix"}),(0,s.jsx)(n.th,{children:"Binary Bits"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da76"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010011"}),"10110"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da7a"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010011"}),"11010"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da7b"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010011"}),"11011"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da7f"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010011"}),"11111"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"da69 (chunk)"}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)("u",{children:"11011010011"}),"01001"]})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"doubling-implications-for-node-operators",children:"Doubling Implications for Node Operators"}),"\n",(0,s.jsxs)(n.p,{children:["One of the implications of doubling for node operators is that the reward chances for a node depends in part on how many other nodes are in its neighbourhood. If it is in a neighbourhood with fewer nodes, its chances of winning rewards are greater. Therefore node operators should make certain to place their nodes into less populated neighbourhoods, and also should look ahead to neighbourhoods at the next depth after a doubling. For more details about how to adjust node placement, see ",(0,s.jsx)(n.a,{href:"/docs/bee/installation/install#set-target-neighborhood-optional",children:"the section on setting a target neighbourhood"})," in the installation guide."]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},28453:(e,n,d)=>{d.d(n,{R:()=>i,x:()=>h});var s=d(96540);const r={},o=s.createContext(r);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function h(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);